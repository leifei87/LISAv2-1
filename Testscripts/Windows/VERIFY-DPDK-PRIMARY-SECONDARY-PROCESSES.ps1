# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License.
param([object] $AllVmData, [object] $CurrentTestData, [object] $TestProvider)

$MIN_KERNEL_VERSION = "4.20"

function Main {
	# Create test result
	$superUser = "root"
	$testResult = $null

	try {
		# Checking PRIMARY/SECONDARY DPDK compatibility
		$compatibleDistro = @("REDHAT", "UBUNTU")
		if (!(Is-DpdkCompatible -CompatibleDistro $compatibleDistro -DetectedDistro $global:DetectedDistro)) {
			return $global:ResultSkipped
		}
		$currentKernelVersion = Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
			-username $user -password $password -command "uname -r"
		if ((Is-DpdkCompatible -KernelVersion $currentKernelVersion -DetectedDistro $global:DetectedDistro) `
			-and ((Compare-KernelVersion $currentKernelVersion $MIN_KERNEL_VERSION) -ge 0)) {
			Write-LogInfo "Confirmed Kernel version supported: $currentKernelVersion"
		} else {
			Write-LogWarn "Unsupported Kernel version: $currentKernelVersion or unsupported distro $($global:DetectedDistro)"
			return $global:ResultSkipped
		}

		# PROVISION VMS FOR LISA WILL ENABLE ROOT USER AND WILL MAKE ENABLE PASSWORDLESS AUTHENTICATION ACROSS ALL VMS IN SAME HOSTED SERVICE.
		Provision-VMsForLisa -allVMData $allVMData -installPackagesOnRoleNames "none"
		#endregion

		Write-LogInfo "Generating constants.sh ..."
		$constantsFile = "$LogDir\constants.sh"
		Set-Content -Value "#Generated by Azure Automation." -Path $constantsFile
		Add-Content -Value "vms=$($vmData.RoleName)" -Path $constantsFile
		Add-Content -Value "client=$($vmData.InternalIP)" -Path $constantsFile
		Add-Content -Value "server=$($vmData.InternalIP)" -Path $constantsFile

		foreach ($param in $currentTestData.TestParameters.param) {
			Add-Content -Value "$param" -Path $constantsFile
		}

		Write-LogInfo "constants.sh created successfully..."
		Write-LogInfo (Get-Content -Path $constantsFile)

		#region BUILD INSTALL RDMA CORE
		$build_install_rdma_core = @"
cd /root/
./build_install_rdma_core.sh > buildInstallRdmaCoreLogs.txt 2>&1
"@
		Set-Content "$LogDir\StartBuildInstallRdmaCore.sh" $build_install_rdma_core
		Copy-RemoteFiles -uploadTo $vmData.PublicIP -port $vmData.SSHPort `
			-files "$constantsFile,$LogDir\StartBuildInstallRdmaCore.sh" -username $superUser -password $password -upload

		Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
			-username $superUser -password $password -command "chmod +x *.sh" | Out-Null
		$testJob = Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
			-username $superUser -password $password -command "./StartBuildInstallRdmaCore.sh" -RunInBackground
		#endregion

		#region MONITOR BUILD INSTALL RDMA CORE
		while ((Get-Job -Id $testJob).State -eq "Running") {
			$currentStatus = Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
				-username $superUser -password $password -command "tail -2 buildInstallRdmaCoreLogs.txt | head -1"
			Write-LogInfo "Current Test Status : $currentStatus"
			Wait-Time -seconds 20
		}
		$dpdkStatus = Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
			-username $superUser -password $password -command "cat /root/state.txt"
		$testResult = Get-TestStatus $dpdkStatus
		if ($testResult -ne "PASS") {
			Copy-RemoteFiles -downloadFrom $vmData.PublicIP -port $vmData.SSHPort `
				-username $superUser -password $password -download -downloadTo $LogDir -files "*.txt, *.log"
			return $testResult
		}

		Write-LogInfo "RDMA requires a VM reboot. Restarting..."
		$restartStatus = $TestProvider.RestartAllDeployments($allVMData)
		if ($restartStatus -eq "True") {
			Write-LogInfo "RDMA VM reboot was successful."
		} else {
			Write-LogErr "RDMA VM reboot was not successful."
			return "FAIL"
		}

		#region INSTALL CONFIGURE DPDK
		$install_configure_dpdk = @"
cd /root/
./dpdkSetup.sh > dpdkConsoleLogs.txt 2>&1
"@
		Set-Content "$LogDir\StartDpdkPrimarySecondarySetup.sh" $install_configure_dpdk
		Copy-RemoteFiles -uploadTo $vmData.PublicIP -port $vmData.SSHPort `
			-files "$constantsFile,$LogDir\StartDpdkPrimarySecondarySetup.sh" -username $superUser -password $password -upload

		Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
			-username $superUser -password $password -command "chmod +x *.sh" | Out-Null
		$testJob = Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
			-username $superUser -password $password -command "./StartDpdkPrimarySecondarySetup.sh" -RunInBackground
		#endregion

		#region MONITOR INSTALL CONFIGURE DPDK
		while ((Get-Job -Id $testJob).State -eq "Running") {
			$currentStatus = Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
				-username $superUser -password $password -command "tail -2 dpdkConsoleLogs.txt | head -1"
			Write-LogInfo "Current Test Status : $currentStatus"
			Wait-Time -seconds 20
		}
		$dpdkStatus = Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
			-username $superUser -password $password -command "cat /root/state.txt"
		$testResult = Get-TestStatus $dpdkStatus
		if ($testResult -ne "PASS") {
			Copy-RemoteFiles -downloadFrom $vmData.PublicIP -port $vmData.SSHPort `
				-username $superUser -password $password -download -downloadTo $LogDir -files "*.txt, *.log"
			return $testResult
		}

		#region INSTALL CONFIGURE DPDK PRIMARY/SECONDARY
		$install_configure_primary_secondary_processes = @"
cd /root/
./dpdk_verify_primary_secondary.sh > dpdkVerifyPrimarySecondaryLogs.txt 2>&1
. utils.sh
collect_VM_properties
"@
		Set-Content "$LogDir\StartDpdkPrimarySecondaryVerify.sh" $install_configure_primary_secondary_processes
		Copy-RemoteFiles -uploadTo $vmData.PublicIP -port $vmData.SSHPort `
			-files "$constantsFile,$LogDir\StartDpdkPrimarySecondaryVerify.sh" -username $superUser -password $password -upload

		Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
			-username $superUser -password $password -command "chmod +x *.sh" | Out-Null
		$testJob = Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
			-username $superUser -password $password -command "./StartDpdkPrimarySecondaryVerify.sh" -RunInBackground
		#endregion

		#region MONITOR INSTALL CONFIGURE DPDK PRIMARY/SECONDARY
		while ((Get-Job -Id $testJob).State -eq "Running") {
			$currentStatus = Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
				-username $superUser -password $password -command "tail -2 dpdkVerifyPrimarySecondaryLogs.txt | head -1"
			Write-LogInfo "Current Test Status : $currentStatus"
			Wait-Time -seconds 20
		}
		$dpdkStatus = Run-LinuxCmd -ip $vmData.PublicIP -port $vmData.SSHPort `
			-username $superUser -password $password -command "cat /root/state.txt"
		$testResult = Get-TestStatus $dpdkStatus
		if ($testResult -ne "PASS") {
			Copy-RemoteFiles -downloadFrom $vmData.PublicIP -port $vmData.SSHPort `
				-username $superUser -password $password -download -downloadTo $LogDir -files "*.txt, *.log"
			$primarySecondaryLogFile = "primary_secondary.log"
			if (Test-Path (Join-Path $LogDir $primarySecondaryLogFile)) {
				$dpdkPrimarySecondaryLog = Get-Content (Join-Path $LogDir $primarySecondaryLogFile) -Raw
				if ($dpdkPrimarySecondaryLog -and ($dpdkPrimarySecondaryLog -like "*Finished process init*")) {
					Write-LogWarn "The secondary process exited with error, but the primary secondary processes work."
					$testResult = "PASS"
				} else {
					Write-LogErr "The secondary process failed with error: ${dpdkPrimarySecondaryLog}."
				}
			} else {
				return $testResult
			}
		}

		Copy-RemoteFiles -downloadFrom $vmData.PublicIP -port $vmData.SSHPort `
			-username $superUser -password $password -download -downloadTo $LogDir -files "*.txt, *.log"
	} catch {
		$ErrorMessage =  $_.Exception.Message
		$ErrorLine = $_.InvocationInfo.ScriptLineNumber
		Write-LogErr "EXCEPTION : $ErrorMessage at line: $ErrorLine"
		$testResult = "FAIL"
	}
	return $testResult
}

Main
